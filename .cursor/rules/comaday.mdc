---
alwaysApply: true
---
프로젝트 개요
프로젝트명: 코마데이 (보드게임 포인트 관리 시스템)
스택: React (Frontend) + NestJS (Backend) + PostgreSQL
목적: 보드게임 당일 세션용 초간단 포인트 관리 및 랭킹 시스템
특징: 임시 계정 생성, 서버 온/오프 방식, 데이터 영속성 불필요
아키텍처 및 구조
Backend (NestJS)
src/
├── modules/
│   ├── auth/          # 초간단 로그인/계정생성
│   ├── users/         # 당일 사용자 관리
│   ├── points/        # 포인트 거래
│   └── rankings/      # 실시간 랭킹
├── common/
│   ├── guards/        # 간단한 세션 가드
│   ├── filters/       # 예외 필터
│   └── decorators/    # 커스텀 데코레이터
└── database/
    └── entities/      # 최소한의 엔티티
Frontend (React)
src/
├── components/
│   ├── common/        # 공통 컴포넌트
│   ├── auth/          # 로그인/계정생성
│   ├── game/          # 포인트 거래
│   └── ranking/       # 랭킹 보드
├── pages/             # 페이지 컴포넌트 (로그인, 메인)
├── hooks/             # 커스텀 훅
├── services/          # API 서비스
├── store/             # 최소한의 상태 관리
└── types/             # TypeScript 타입 정의
코딩 컨벤션
일반 규칙
언어: TypeScript 사용 필수
코드 스타일: Prettier + ESLint 설정 적용
네이밍: camelCase (변수, 함수), PascalCase (클래스, 컴포넌트, 인터페이스)
파일명: kebab-case 사용 (예: point-transaction.service.ts)
Backend (NestJS) 규칙
모듈 구조: 각 도메인별로 모듈 분리
서비스: 비즈니스 로직은 서비스 레이어에서 처리
컨트롤러: HTTP 요청/응답만 처리, 비즈니스 로직 포함 금지
엔티티: TypeORM 데코레이터 사용, 관계 설정 명확히
DTO: 입력 검증을 위한 class-validator 사용
에러 처리: 커스텀 예외 클래스 생성 및 활용
typescript
// 예시: 간단한 인증 서비스
@Injectable()
export class AuthService {
  async loginOrCreate(username: string, password: string): Promise<User> {
    // 사용자 존재 여부 확인
    let user = await this.userRepository.findOne({ where: { username } });
    
    if (!user) {
      // 계정이 없으면 즉시 생성
      user = await this.userRepository.save({
        username,
        password: await bcrypt.hash(password, 10),
        totalPoints: 1000, // 초기 포인트
      });
    } else {
      // 비밀번호 확인
      const isValid = await bcrypt.compare(password, user.password);
      if (!isValid) throw new UnauthorizedException('잘못된 비밀번호');
    }
    
    return user;
  }
}
Frontend (React) 규칙
컴포넌트: 함수형 컴포넌트 + React Hooks 사용
상태 관리: 전역 상태는 Redux Toolkit 또는 Zustand 사용
API 호출: React Query/TanStack Query 사용 권장
스타일링: Tailwind CSS 또는 styled-components 사용
폴더 구조: 도메인별 폴더 구조 유지
typescript
// 예시: 로그인/가입 컴포넌트
interface LoginFormProps {
  onLogin: (username: string, password: string) => void;
}

export const LoginForm: React.FC<LoginFormProps> = ({ onLogin }) => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onLogin(username, password); // 계정 없으면 자동 생성
  };

  return (
    <form onSubmit={handleSubmit}>
      <input 
        placeholder="아이디 (계정이 없으면 자동 생성됩니다)"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
      />
      <input 
        type="password"
        placeholder="비밀번호"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <button type="submit">로그인 / 계정생성</button>
    </form>
  );
};
데이터베이스 설계 가이드
최소한의 테이블 구조 (참고용)
sql
-- 당일 사용자 테이블
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  total_points INTEGER DEFAULT 1000
);

-- 포인트 거래 내역 테이블  
CREATE TABLE point_transactions (
  id SERIAL PRIMARY KEY,
  from_user_id INTEGER REFERENCES users(id),
  to_user_id INTEGER REFERENCES users(id),
  amount INTEGER NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);
연속 거래 제한 로직
동일한 수신자에게 3회 연속 포인트 지급 방지
point_transactions 테이블에서 최근 거래 기록 조회
비즈니스 로직에서 검증 후 거래 승인/거부
API 설계 원칙
초간단 API 구조
POST   /api/auth/login              # 로그인/계정자동생성
GET    /api/users/me                # 내 정보
GET    /api/users/rankings          # 실시간 랭킹
POST   /api/points/transfer         # 포인트 이전
GET    /api/points/history/:userId  # 내 거래 내역
GET    /api/users/list              # 전체 사용자 목록 (포인트 지급할 상대 선택용)
응답 형식 표준화
typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
  };
  meta?: {
    page?: number;
    limit?: number;
    total?: number;
  };
}
보안 및 검증 규칙
최소한의 세션 관리
메모리 기반 세션 (서버 재시작시 초기화)
복잡한 토큰 관리 불필요
브라우저 세션 기반으로 충분
입력 검증
사용자명: 영문, 숫자, 한글만 허용 (3-10자)
비밀번호: 최소 3자리 (정말 간단하게)
포인트 거래: 양수만, 잔액 확인
핵심 비즈니스 규칙
typescript
// 연속 거래 제한 (동일한 상대에게 3회 연속 방지)
async canTransferPoints(fromUserId: number, toUserId: number): Promise<boolean> {
  const lastThreeTransactions = await this.pointTransactionRepository
    .find({
      where: { fromUserId },
      order: { createdAt: 'DESC' },
      take: 3
    });
  
  // 최근 3건이 모두 같은 상대에게라면 거부
  const allToSameUser = lastThreeTransactions.length === 3 && 
    lastThreeTransactions.every(t => t.toUserId === toUserId);
  
  return !allToSameUser;
}

// 포인트 이전
async transferPoints(fromUserId: number, toUserId: number, amount: number): Promise<void> {
  const fromUser = await this.userRepository.findOne({ where: { id: fromUserId } });
  const toUser = await this.userRepository.findOne({ where: { id: toUserId } });
  
  if (fromUser.totalPoints < amount) {
    throw new BadRequestException('포인트가 부족합니다');
  }
  
  if (!(await this.canTransferPoints(fromUserId, toUserId))) {
    throw new BadRequestException('동일한 상대에게 3회 연속 지급할 수 없습니다');
  }
  
  // 트랜잭션으로 포인트 이동
  await this.dataSource.transaction(async manager => {
    await manager.update(User, fromUserId, { 
      totalPoints: () => `total_points - ${amount}` 
    });
    await manager.update(User, toUserId, { 
      totalPoints: () => `total_points + ${amount}` 
    });
    await manager.save(PointTransaction, {
      fromUserId, toUserId, amount
    });
  });
}
성능 최적화 가이드
Database
메모리 위주 동작 (데이터 크기가 작음)
필수 인덱스만 생성
복잡한 쿼리 최적화 불필요
Frontend
단순한 상태 관리 (로그인 사용자 + 랭킹 데이터)
실시간 랭킹 업데이트 (폴링 또는 WebSocket)
빠른 UI 응답성에 집중
Backend
메모리 기반 세션 저장
간단한 응답 캐싱
불필요한 미들웨어 제거
테스트 전략
Backend 테스트
단위 테스트: Jest + Supertest
통합 테스트: 실제 DB 연동 테스트
E2E 테스트: 주요 비즈니스 플로우
Frontend 테스트
컴포넌트 테스트: React Testing Library
단위 테스트: Jest
E2E 테스트: Cypress 또는 Playwright
배포 및 환경 설정
환경 변수 관리 (참고용)
env
DATABASE_URL=postgresql://user:password@localhost:5432/comadae
SESSION_SECRET=simple-secret-key
INITIAL_POINTS=1000
PORT=3000
Docker 구성 (참고용)
dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "run", "start:prod"]
개발 워크플로우
Git 브랜치 전략
main: 프로덕션 브랜치
develop: 개발 브랜치
feature/*: 기능 개발 브랜치
hotfix/*: 긴급 수정 브랜치
커밋 메시지 규칙
feat: 새로운 기능 추가
fix: 버그 수정
docs: 문서 수정
style: 코드 포맷팅
refactor: 코드 리팩토링
test: 테스트 코드
chore: 빌드/설정 관련
추가 고려사항
핵심 개발 포인트
서버 켜면 바로 사용 가능한 구조 유지
복잡한 설정이나 초기화 작업 최소화
빠른 계정 생성으로 즉시 게임 시작 가능
실시간 기능 구현 예시
typescript
// 간단한 실시간 랭킹 업데이트
@Controller('rankings')
export class RankingsController {
  @Get()
  async getCurrentRankings(): Promise<User[]> {
    return await this.userRepository.find({
      select: ['username', 'totalPoints'],
      order: { totalPoints: 'DESC' }
    });
  }
}

// 프론트엔드에서 폴링으로 랭킹 업데이트
const useRankings = () => {
  const [rankings, setRankings] = useState([]);
  
  useEffect(() => {
    const interval = setInterval(async () => {
      const response = await fetch('/api/users/rankings');
      const data = await response.json();
      setRankings(data);
    }, 3000); // 3초마다 업데이트
    
    return () => clearInterval(interval);
  }, []);
  
  return rankings;
};
UI 구성 요소
로그인/가입 폼
포인트 이전 폼 (상대방 선택 + 포인트 입력)
실시간 랭킹 보드
내 거래 내역
이 룰을 기반으로 코마데이 프로젝트를 개발하시면 확장 가능하고 유지보수하기 쉬운 보드게임 포인트 관리 시스템을 구축할 수 있을 것입니다.

